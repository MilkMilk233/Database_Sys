# SQL学习笔记

Last update: 2022/4/12

FEATURE: NOT SENSITIVE ON UPPER & LOWER LETTER.

[TOC]

## INSERT:

```sql
INSERT INTO INSTRUCTOR VALUES ('10211', 'SMITH', 'BIOLOGY',66000 )
# WHICH IS EQUIVALENT TO
INSERT INTO INSTRUCTOR(ID, NAME, DEPT_NAME, SALARY) VALUES ('10211', 'SMITH', 'BIOLOGY',66000)
```

除了可以insert value，还可以将别的表select来的数据insert进去（格式要求相同）

```SQL
INSERT INTO INSTRUCTOR
	SELECT ID, NAME, DEPT_NAME, 19000
	FROM STUDENT
	WHERE DEPT_NAME = 'MUSIC' AND TOTAL_CRED > 144;
```

## UPDATE:

更新表中的所有数据：

```SQL
UPDATE INSTRUCTOR
	SET SALARY = SALARY * 1.05
```

更新表中符合条件的数据：

```SQL
UPDATE INSTRUCTOR
	SET SALARY = SALARY * 1.05
	WHERE SALARY < 70000
```

```SQL
UPDATE INSTRUCTOR
	SET SALARY = SALARY * 1.05
	WHERE SALARY < (SELECT AVG(SALARY) FROM INSTRUCTOR);
```

```SQL
# ORDER SEQUENCE IS ALSO IMPORTANT
UPDATE INSTRUCTOR
	SET SALARY = SALARY * 1.03
	WHERE SALARY > 100000
UPDATE INSTRUCTOR
	SET SALARY = SALARY * 1.05
	WHERE SALARY < 100000
```

```SQL
# CASE, LIKE IN VERILOG
UPDATE INSTRUCTOR
	SET SALARY = CASE
				WHEN SALARY <= 100000 THEN SALARY * 1.05
				ELSE SALARY * 1.03
				END
```

## DELETE:

只是删除所有数据，不删除格式

```sql
DELETE FROM STUDENT
```

删除特定符合条件的数据

```SQL
DELETE FROM STUDENT
WHERE DAD = 'LIGANG'
```

```SQL
DELETE FROM INSTRUCTOR WHERE DEPT_NAME IN (SELECT DEPT_NAME FROM DEPARTMENT WHERE BUILDING = TB)
```

```SQL
DELETE FROM INSTRUCTOR WHERE SALARY < (SELECT AVG(SALARY) FROM INSTRUCTOR)
```

## DROP:

数据连同格式一起删除

```SQL
DROP TABLE R
```

## ALTER:

```SQL
ALTER TABLE R ADD A D  # JOIN R WITH NEW ATTRIBUTE OF NAME A AND TYPE D
```

```SQL
ALTER TABLE R DROP A # DELETE CERTAIN COL OF TABLE R
```



## BASIC GRAMMAR:

```SQL
SELECT A1 FROM R1 WHERE ATTRIBUTE = 'XXX'
```

```SQL
SELECT * FROM R1
```

```SQL
SELECT DISTINCT A1 FROM R1
```

```SQL
SELECT '437' AS FOO # OUTCOME: 1X1 RESULT, '437' AS CONTEXT, FOO AS THE ONLY COL TITLE 
```

```SQL
SELECT 'ABC' FROM TEACHERS #ONE COL OF EQUAL LENGTH AS TABLE TEACHERS, FULL OF 'ABC'
```

```SQL
SELECT SALARY/12 FROM INSTRUCTORS # SUPPORT +, -, *, / ON NUMERIC VAL
```

```SQL
SELECT NAME FROM INSTRUCTORS WHERE DEPT_NAME = 'MATH' AND SALARY > 90000
```

```SQL
# CARTESIAN PRODUCT
SELECT * FROM INSTRUCTORS, TEACHES;
# NATURAL JOIN
SELECT * FROM INSTRUCTORS, TEACHES WHERE INSTRUCTOR.ID = TEACHES.ID;
```

```SQL
#SELECT AND COMPARE IN ONE TABLE
SELECT DISTINCT T.NAME
FROM INSTRUCTOR T, INSTRUCTOR AS S  # KEYWORD 'S' CAN BE OMITTED, EQUIVALENT
WHERE T.SALARY > S.SALARY AND S.DEPT_NAME = 'BIOLOGY'
```

```SQL
SELECT NAME FROM INSTRUCTOR WHERE NAME LIKE '%DAR%'  # FIND NAME CONTAINING 'DAR', % FOR MANY CHARTERS
```

```SQL
SELECT NAME FROM INSTRUCTOR WHERE NAME LIKE '%D\%R%'  # FIND NAME CONTAINING 'D%R', BLACKSLASH \ TO DEBUFF
# SIMILARYLY: _ MATCHES EXACTLY ONE CHAR, _ _ _ % MATCHES AT LEAST 3 CHARS, 'AB%' IS STARTS WITH 'AB'
```

```SQL
SELECT DISTINCT NAME FROM INSTRUCTORS ORDER BY NAME # DEFAULT ASCENDING
SELECT DISTINCT NAME FROM INSTRUCTORS ORDER BY NAME, GENDER DESC # SORT ON 2 ATTRIBUTES
SELECT DISTINCT NAME FROM INSTRUCTORS ORDER BY NAME ASC # DEFAULT
```

```SQL
# FOR THOSE WHOSE 90000 <= SALARY <= 100000
SELECT NAME FROM INSTRUCTORS WHERE SALARY BETWEEN 90000 AND 100000
```

```SQL
# THE TYPE AND NAME (CAN BE CHANGED BY 'AS') OF THE ATTRIBUTE SHOULD BE THE SAME
(SELECT NAME FROM CRAZY_PLAYER)
UNION
(SELECT NAME FROM GOOD_STUDENT);

(SELECT NAME FROM CRAZY_PLAYER)
INTERSECT
(SELECT NAME FROM GOOD_STUDENT);

(SELECT NAME FROM CRAZY_PLAYER)
EXCEPT
(SELECT NAME FROM GOOD_STUDENT);
#BY DEFAULT, NO DUMPLICATES.
#OTHERWISE, USE KEYWORD 'UNION ALL' 'INTERSECT ALL' 'EXCEPT ALL'
```

```SQL
5 + NULL # NULL
5 < NULL # UNKNOWN
NULL <> NULL # UNKNOWN
NULL = NULL # UNKNOWN
# UNKNOWN CAN BE EITHER TRUE OR FALSE.
(TRUE AND UNKNOWN) # UNKNOWN
(FALSE AND UNKNOWN) # FALSE
(UNKNOWN AND UNKNOWN) # UNKNOWN
(TRUE OR UNKNOWN) # TRUE
(FALSE OR UNKNOWN) # UNKNOWN
(UNKNOWN OR UNKNOWN) # UNKNOWN
# IF UNKNOWN APPEARS IN WHERE CLAUSE, CAN BE REGARDED AS 'FALSE'
```

```SQL
SELECT NAME FROM INSTRUCTOR WHERE SALARY IS NULL
```

```SQL
SELECT AVG(SALARY) FROM INSTRUCTORS
SELECT COUNT(DISTINCT ID) FROM INSTRUCTORS
SELECT COUNT(*) FROM COURSES
SELECT MIN(SALARY) FROM INSTRUCTORS
SELECT SUM(SALARY) FROM INSTRUCTORS
```

```SQL
# CALCULATE EACH DEPT'S INSTRUCTORS' AVG_SALARY
SELECT DEPT_NAME, AVG(SALARY) AS AVG_SALARY
FROM INSTRUCTORS
GROUP BY DEPT_NAME
# CAUTION: "SELECT DEPT_NAME, ID .... GROUP BY DEPT_NAME" IS ILLEGAL, "ID" SHOULD NOT APPEAR
```

```SQL
SELECT DEPT_NAME, AVG(SALARY) AS AVG_SALARY
FROM INSTRUCTORS
GROUP BY DEPT_NAME HAVING AVG(SALARY) > 42000
# "HAVING" IS SIMILAR TO "WHERE", BUT APPEARS IN "GROUP BY"
```

```SQL
# SET MEMBERSHIP
SELECT DISTINCT COURSE_ID FROM SECTION
WHERE COURSE_ID (NOT) IN (SELECT COURSE_ID FROM ALL_COURSES)
```

```SQL
# SOME - COMPARE INSIDE ONE TABLE, SELECT INSTRUCTORS MORE THAN LEAST IN BIO DEPT
# ACTUALLY, 'SOME' REALLY STANDS FOR SOME.
SELECT NAME FORM INSTRUCTOR
WHERE SALARY > SOME(SELECT SALARY FROM INSTRUCTOR WHERE DEPT_NAME = 'BIOLOGY')
```

```SQL
# SIMILARYLY, ALL APPEARS
SELECT NAME FROM INSTRUCTOR
WHERE SALARY > ALL(SELECT SALARY FROM INSTRUCTOR WHERE DEPT_NAME = 'BIOLOGY')
```

```SQL
# IF "EXIST R" AND R IS NOT EMPTY THEN EQUIVALENT TO "TRUE"
# THE NAME "S" CAN BE INHERITED IN "WHERE" SUBQUERY
SELECT COURSE_ID FROM SECTION AS S
WHERE SEMESTER = 'FALL' AND YEAR = 2017 AND 
	EXISTS (SELECT * FROM SECTION AS T WHERE SEMESTER = 'SPRING' AND YEAR = '2018'
											AND S.COURSE_ID = T.COURSE_ID)
```

```SQL
# FIND ALL STUDENTS WHO HAVE TAKEN ALL COURSES OFFERED IN THE BIOLOGY DEPT.
SELECT DISTINCT S.ID, S.NAME
FROM STUDENT AS S
WHERE NOT EXISTS ((SELECT COURSE_ID FROM COURSE WHERE DEPT_NAME = 'BIOLOGY')
					EXCEPT
					(SELECT T.COURSE_ID FROM TAKES AS T WHERE S.ID = T.ID));
```

```SQL
# FIND ALL COURSES THAT WERE OFFERED AT MOST ONCE IN 2017
# THE SELECT ALLOWS DUMPLICATES BY DEFAULT. OTHERWISE, USE DISTINCT.
SELECT T.COURSE_ID FROM COURSE AS T
WHERE UNIQUE(SELECT R.COURSE_ID FROM SECTION AS R WHERE T.COURSE_ID = R.COURSE_ID AND R.YEAR = 2017)
# NOTE: UNIQUE(0) = TRUE, UNIQUE(1) = TRUE
```

```SQL
# WITH CAN CREATE A TEMPORARY RELATION, ONLY VALID IN THIS SQL
WITH MAX_BUDGET(VALUE) AS (SELECT MAX(BUDGET) FROM DEPARTMENT)
SELECT DEPARTMENT.NAME
FROM DEPARTMENT, MAX_BUDGET
WHERE DEPARTMENT.BUDGET = MAX_BUDGET.VALUE
```



## Join

### Natural Join

前面提到的insert是增加行。如果要增加列，一般用join等方法。

```SQL
# 在这里，name是student里的attribute，course_id是takes的attribute
SELECT NAME, COURSE_ID FROM STUDENT, TAKES WHERE STUDENT.ID = TAKES.ID;
# 同时，也可以用natural join表示
SELECT NAME, COURSE_ID FROM STUDENT NATURAL JOIN TAKES;
```

但natural join在某种情况下会变得很危险。

natural join的匹配机制是，假如A表格有a，b，c三个attribute，B表格有a, b, e, f四个attribute。此时因为a和b在两个表格中都存在，所以系统会筛选出a和b完全match的一副tuple拼接在一起。若在这种情况下，我们不希望全部匹配（比如说我只是希望match a 这个pair），那么就要手工通过where A.a = B.a 进行匹配，不可以用natural join。

### Outer Join

效果：减少数据损失，即对natura join产生问题的解决方案。

#### Left Outer Join

还是刚刚的假设，假如A表格有a，b，c三个attribute，B表格有a, b, e, f四个attribute。此时因为a和b在两个表格中都存在，我们要求在**左边**的tuple**全部保留**，并尽可能地寻找右边match的pair，如果都能在a,b这两个attribute上完美match就最好了，没有的话还是要把左边留着，右边的内容就用null替代。剩下右边无法与左边匹配的就扔了吧。

#### Right Outer Join

和上面的类似，只是将左换成右

#### Full Outer Join

和上面的类似，区别在于对匹配不到的结果的处理：不是直接扔掉，而是sign上null后保留在末尾，相当于将所有（不完美匹配a和b的）可能性都加上去了，只是缺失的部分用null填满。（设为代表未知的null）

